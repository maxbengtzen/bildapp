<!doctype html>
<html lang="sv">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Gridprint</title>
    <link rel="icon" href="/favicon.svg" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#00D3BB" />
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Gridprint">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="/icons/apple-touch-icon.png">
    <!-- Din bundlade CSS (t.ex. Tailwind/DaisyUI) -->
    <link rel="stylesheet" href="/output.css">
  </head>
  <body>
    <div class="min-h-dvh bg-base-100">
      <header class="pt-8 pb-4 text-center">
        <h1 class="text-3xl font-extrabold tracking-tight text-teal-700">Gridprint</h1>
        <p class="text-base-content/70 mt-1">Skapa utskriftsvänliga bildrutor i PDF.</p>
      </header>

      <main class="px-5">
        <form id="uploadForm" enctype="multipart/form-data">
          <div class="mx-auto max-w-md">
            <div class="card bg-base-200/60 backdrop-blur-md shadow-xl rounded-3xl">
              <div class="card-body space-y-5">
                <!-- Steg/överblick -->
                <ul class="steps w-full mb-2">
                  <li class="step step-primary">Storlek</li>
                  <li class="step">Bilder</li>
                  <li class="step">Skapa PDF</li>
                </ul>

                <!-- Bildstorlek -->
                <label class="form-control">
                  <div class="label">
                    <span class="label-text font-medium">Bildstorlek (cm)</span>
                    <div class="join hidden sm:inline-flex">
                      <button type="button" class="btn btn-xs join-item btn-outline" data-size="3">3</button>
                      <button type="button" class="btn btn-xs join-item btn-outline" data-size="5">5</button>
                      <button type="button" class="btn btn-xs join-item btn-outline" data-size="7">7</button>
                    </div>
                  </div>
                  <label class="input input-bordered flex items-center gap-2">
                    <input id="size" name="size" class="grow" type="number" step="0.1" value="5.5" placeholder="5.5" aria-describedby="cellSizeHelp" />
                    <span class="opacity-60">cm</span>
                  </label>
                </label>

                <!-- Bilder (dropzone) -->
                <div class="form-control">
                  <div class="label"><span class="label-text font-medium">Bilder</span></div>
                  <label class="border-2 border-dashed rounded-2xl p-6 h-32 text-center cursor-pointer hover:bg-base-200 transition flex flex-col justify-center" for="fileInput">
                    <div class="text-base-content/70">
                      <span class="font-medium">Lägg till bilder</span> eller släpp dem här
                    </div>
                    <div class="text-xs opacity-70 mt-1">PNG/JPG/HEIC/HEIF • flera filer stöds</div>
                    <input id="fileInput" name="images" type="file" accept="image/*" multiple class="hidden" />
                  </label>
                  <!-- Thumbnails -->
                  <div class="text-xs text-base-content/70 mt-1" id="imageCount">0 bilder valda</div>
                </div>


                <!-- CTA -->
                <button type="submit" class="btn btn-primary btn-lg rounded-2xl w-full" id="createBtn" disabled>
                  Skapa PDF
                </button>
                <p class="text-sm text-base-content/70 text-center">
                  PDF genereras i 300 DPI för skarp utskrift.
                </p>
                <p class="text-xs text-base-content/60 text-center">
                  Tips: iOS kan öppna PDF i ny flik i stället för automatisk nedladdning.
                </p>
              </div>
            </div>
          </div>
        </form>
      </main>
    </div>

    <script>
      // iOS Debug logging system
      const isIOS = /iPad|iPhone|iPod/i.test(navigator.userAgent);
      const debugLogs = [];
      
      function debugLog(message, data = null) {
        const timestamp = new Date().toISOString();
        const logEntry = { timestamp, message, data, userAgent: navigator.userAgent };
        debugLogs.push(logEntry);
        console.log(`[DEBUG ${timestamp}] ${message}`, data || '');
        
        // On iOS, also show critical errors in alerts for debugging
        if (isIOS && (message.includes('ERROR') || message.includes('FAIL'))) {
          setTimeout(() => alert(`iOS Debug: ${message}`), 100);
        }
      }
      
      // Global error handlers for iOS debugging
      window.addEventListener('error', (e) => {
        debugLog('ERROR: JavaScript error', {
          message: e.message,
          filename: e.filename,
          lineno: e.lineno,
          colno: e.colno,
          error: e.error?.toString()
        });
      });
      
      window.addEventListener('unhandledrejection', (e) => {
        debugLog('ERROR: Unhandled promise rejection', {
          reason: e.reason?.toString(),
          promise: e.promise
        });
      });

      debugLog('App initialized', { isIOS, userAgent: navigator.userAgent });

      // Apply system theme only (no UI toggle). Uses prefers-color-scheme and keeps in sync.
      function applyTheme(isDark) {
        document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
      }

      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      applyTheme(prefersDark);

      if (window.matchMedia) {
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
          applyTheme(e.matches);
        });
      }

      // Upload form
      const form = document.getElementById('uploadForm');
      const sizeInput = document.getElementById('size');
      const fileInput = document.getElementById('fileInput');
      const imageCount = document.getElementById('imageCount');
      const createBtn = document.getElementById('createBtn');
      const steps = document.querySelectorAll('.step');

      let selectedFiles = [];
      let objectUrls = [];
      let pdfCreationStarted = false;

      function updateSteps() {
        steps.forEach((step, index) => {
          step.className = 'step';
          if (index === 0 && parseFloat(sizeInput.value) > 0) step.classList.add('step-primary');
          if (index === 1 && selectedFiles.length > 0) step.classList.add('step-primary');
          if (index === 2 && pdfCreationStarted) step.classList.add('step-primary');
        });
      }

      // Storleks-badges
      const sizeBadges = document.querySelectorAll('[data-size]');
      sizeBadges.forEach(badge => {
        badge.addEventListener('click', () => {
          sizeInput.value = badge.dataset.size;
          updateSteps();
        });
      });

      // File input + DnD
      fileInput.addEventListener('change', handleFiles);
      
      // iOS Safari often has issues with drag and drop, so add extra safety
      const dropzone = fileInput.parentElement.parentElement; // Assuming label is parent, then div is parent
      
      if (!isIOS) {
        // Only enable drag and drop on non-iOS devices as iOS Safari has limited support
        dropzone.addEventListener('dragover', (e) => {
          e.preventDefault();
          dropzone.classList.add('bg-base-200/60'); // Add a visual cue for drag
        });
        dropzone.addEventListener('dragleave', () => {
          dropzone.classList.remove('bg-base-200/60');
        });
        dropzone.addEventListener('drop', (e) => {
          e.preventDefault();
          dropzone.classList.remove('bg-base-200/60');
          const files = Array.from(e.dataTransfer.files);
          handleNewFiles(files);
        });
        debugLog('Drag and drop enabled (non-iOS)');
      } else {
        debugLog('Drag and drop disabled on iOS');
      }

      function handleFiles(e) {
        debugLog('File input change event triggered', {
          filesLength: e.target.files?.length,
          isIOS
        });
        
        // iOS Safari can sometimes have issues with FileList, so add extra checks
        const files = [];
        if (e.target.files) {
          for (let i = 0; i < e.target.files.length; i++) {
            const file = e.target.files[i];
            if (file) {
              files.push(file);
            }
          }
        }
        
        debugLog('Files extracted from input', { extractedCount: files.length });
        handleNewFiles(files);
      }

      function handleNewFiles(files) {
        try {
          debugLog('handleNewFiles called', {
            filesCount: files.length,
            fileTypes: files.map(f => f.type),
            fileSizes: files.map(f => f.size),
            fileNames: files.map(f => f.name)
          });
          
          const imageFiles = files.filter(f => f.type.startsWith('image/'));
          debugLog('Filtered image files', {
            originalCount: files.length,
            imageCount: imageFiles.length,
            rejectedFiles: files.filter(f => !f.type.startsWith('image/')).map(f => ({ name: f.name, type: f.type }))
          });
          
          selectedFiles = [...selectedFiles, ...imageFiles];
          createBtn.disabled = selectedFiles.length === 0;
          renderThumbnails();
          updateSteps();
          
          debugLog('Files added successfully', { totalSelected: selectedFiles.length });
        } catch (err) {
          debugLog('ERROR: File handling failed', { error: err.message, stack: err.stack });
          console.error('File handling error:', err);
          alert('Kunde inte lägga till filerna: ' + err.message);
        }
      }

      function renderThumbnails() {
        // Städa gamla objectURLs
        objectUrls.forEach(u => { try { URL.revokeObjectURL(u); } catch {} });
        objectUrls = [];

        imageCount.textContent = `${selectedFiles.length} bilder valda`;
        createBtn.disabled = selectedFiles.length === 0;
      }

      function removeFile(index) {
        selectedFiles.splice(index, 1);
        renderThumbnails();
        updateSteps();
      }

      sizeInput.addEventListener('input', () => { updateSteps(); });
      updateSteps();

      // Hjälpfunktion för busy state
      async function withBusy(btn, fn) {
        const oldHTML = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = 'Skapar...';
        try {
          return await fn();
        } finally {
          btn.innerHTML = oldHTML;
          btn.disabled = selectedFiles.length === 0;
        }
      }

      // Nedladdning med iOS-fallback
      function saveBlob(blob, filename) {
        debugLog('saveBlob called', { blobSize: blob.size, blobType: blob.type, filename, isIOS });
        
        try {
          const url = URL.createObjectURL(blob);
          debugLog('Object URL created', { url: url.substring(0, 50) + '...' });
          
          if (isIOS) {
            debugLog('Using iOS fallback - opening in new tab');
            // Öppna i ny flik
            const newWindow = window.open(url, '_blank');
            if (!newWindow) {
              debugLog('ERROR: Failed to open new window - popup blocked?');
              alert('Popup blockerad? PDF skapad men kunde inte öppnas automatiskt.');
            } else {
              debugLog('New window opened successfully');
            }
            setTimeout(() => {
              URL.revokeObjectURL(url);
              debugLog('Object URL revoked after timeout');
            }, 10_000);
            return;
          }
          
          debugLog('Using standard download method');
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          debugLog('Standard download completed');
        } catch (err) {
          debugLog('ERROR: saveBlob failed', { error: err.message, stack: err.stack });
          alert('Kunde inte spara PDF: ' + err.message);
        }
      }

      // Submit
      form.addEventListener('submit', (e) => {
        e.preventDefault();
        debugLog('Form submitted', { selectedFilesCount: selectedFiles.length });
        
        if (selectedFiles.length === 0) {
          debugLog('ERROR: No files selected');
          alert('Välj bilder först');
          return;
        }
        const sizeVal = Math.max(0.1, parseFloat(sizeInput.value) || 5.5);
        debugLog('Starting PDF creation', { sizeVal, filesCount: selectedFiles.length });

        withBusy(createBtn, async () => {
          try {
            // Aktivera steg 3 när PDF-skapandet startar
            pdfCreationStarted = true;
            updateSteps();
            
            // Bygg FormData direkt från selectedFiles
            debugLog('Building FormData');
            const data = new FormData();
            data.append('size', String(sizeVal));
            
            selectedFiles.forEach((file, index) => {
              debugLog(`Adding file ${index}`, { name: file.name, type: file.type, size: file.size });
              data.append('images', file, file.name);
            });
            
            debugLog('FormData built, sending request to /upload');

            let res;
            try {
              res = await fetch('/upload', {
                method: 'POST',
                body: data,
                // Add explicit headers for iOS compatibility
                headers: {
                  // Don't set Content-Type - let browser set it with boundary
                }
              });
              debugLog('Fetch completed', {
                status: res.status,
                statusText: res.statusText,
                headers: Object.fromEntries(res.headers.entries())
              });
            } catch (networkErr) {
              debugLog('ERROR: Network fetch failed', { error: networkErr.message, stack: networkErr.stack });
              console.error('Fetch error:', networkErr);
              alert('Nätverksfel: ' + networkErr.message);
              return;
            }

            // Om servern svarar med HTML/text, visa fel
            const contentType = res.headers.get('Content-Type') || '';
            debugLog('Response details', {
              ok: res.ok,
              status: res.status,
              contentType,
              contentLength: res.headers.get('Content-Length')
            });
            
            if (!res.ok) {
              const text = await res.text();
              debugLog('ERROR: Server error response', { status: res.status, text: text.slice(0, 500) });
              console.error('Upload failed:', res.status, text);
              alert(`Fel ${res.status}: ${text}`);
              return;
            }
            
            if (!contentType.includes('application/pdf')) {
              // Kan hända vid felaktig SW-cache eller serverfel
              const text = await res.text();
              debugLog('ERROR: Wrong content type', { contentType, responseText: text.slice(0, 500) });
              console.warn('Ov. innehållstyp, förväntade PDF. Svar:', text.slice(0, 500));
              alert('Servern returnerade inte en PDF. Kontrollera backend eller Service Worker.');
              return;
            }

            debugLog('Converting response to blob');
            const blob = await res.blob();
            debugLog('Blob created', { size: blob.size, type: blob.type });
            
            if (!blob || blob.size === 0) {
              debugLog('ERROR: Empty blob received');
              alert('Tom PDF mottagen.');
              return;
            }

            debugLog('Saving blob as PDF');
            saveBlob(blob, 'bilder.pdf');
            debugLog('PDF save initiated successfully');

            // Nollställ
            selectedFiles = [];
            pdfCreationStarted = false;
            renderThumbnails();
            updateSteps();
            createBtn.disabled = true; // Disable button after successful upload
            
          } catch (err) {
            debugLog('ERROR: Unexpected error in form submit', { error: err.message, stack: err.stack });
            throw err; // Re-throw to be caught by withBusy
          }
        });
      });

      // Registrera SW om den finns (se till att /sw.js inte cache:ar /upload)
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/sw.js')
            .catch(err => console.warn('SW registration failed:', err));
        });
      }
    </script>
  </body>
</html>
